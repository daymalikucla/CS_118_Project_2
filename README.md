# CS118 Project 2

Malik Day; 005668317; dayxx369@ucla.edu
Quinn Hammel; 305325907; [INSERT EMAIL ADDRESS]

This is the repo for spring 2022 cs118 project 2.

Discussing the client code, essentially, we create include all modules associated with accessing functions from standard libraries. There are also helper functions implemented to print out messages regarding building packets and if packets were received or sent (or resent). There's a packet struct to create the packet object. The client then establishes a connection to the server (or the proxy to test packet lost) using the corresponding port number passed through in the interface. After establishing the connection, the client sends a syn packet and waits to receive the syn packet from server. Once received, the client builds and sends the first packet (along with a duplicate of the first packet) and then implements GBN by building and sending packets until we reached the end of the window or there's no more data to be sent over (whichever comes first). From here, we keep reading in the ack packet received from the server to see if the ack number is within an array of expected acks to be received. If it is, then the client acknowledges the packet, print out the received message and builds and sends the next packet and increments the window to the next. If the ack number is not what it's expected, then we check to see if the timer ran out; if it did run out, then we resend all previous packets that were in the window. We used s and e values to indicate the start and end ith number packet and s_mod and e_mod to modularize s nad e to access the index packet properly. Once s and e are equal, then there's no more new data for the client to send to server, so the client closes the file and sends a fin packet. Once the fin is acknowledged, the client will wait for a fin from the server, and when that's completed, the connections are shut down.  For the server, it sets up the socket (just liek the client) to establish a connection. The server then waits to receive a syn packet from client, and acknowledges it once received. The server then sends a syn packet to client and waits for that to be recieved. Once received, the server will then read in what was the last packet to be acknowledged from the client. If the received packet number match the previous ack_num, the server builds and sends the ack packet to client, while tracking the previous sequence number and ack number. When the server receives a fin packet, it will send over an acknowledgement and break out of the while loop. The server will then close the file and send over a fin packet. Once the fin packet from the client is received, the server will then wait to receive an ack from cleint regarding the server's fin. Once received, the program terminates. Please note that whenever we send over a packet, we create a timer and check to see if that timer expires and build and resend the packet if it failed to be delivered in the appropriate time (including datagrams, syn and fin packets for client and server)

One issue we came across was how to create a cyclical window. We cannot just create a list and keep apending it to the end without tracking the size if the window, so we needed to make sure that we were not exceeding the provided window of packets to send (from client to server). Creating the s and e were helpful to track this, but in addition, we created s_mod and e_mod so that we can modularize the values. s was the ith packet (in total) at the beginning of the window while e was the ith packet (in total) at the end of the window; modularizing these values helped up keep track of the window and access the proper pack index to create and send (when appropriate) within the packet list. This was also used if the timer ran out and we needed to resend all the current packets in the window.

Another issue faced was how to recognize the appropriate ack number received from server. Inittially, we programmed the code to expect just the next sequential sequence number and ack number from server to match, but the issue is that an ack can be lost from server to client. We therefore created another list (pck_seqnum_list) that contained the ack numbers of the packets that were built and sent to server. Once an ack was received and the number was contained within pck_seqnum_list, we then updated the list by inserting seqnum into pck_seqnum_list of a packet that was just built and sent over to server (using the s_mod index to specifiy the index location). pck_seqnum_list size was the max size of the window (which could be 10 or less). When there was no more packets to be created (i.e. m was 0), then we inserted MAX_SEQN value wat the s_mod location so that we do not create a seqnum to be included into the list and to signify that there should be no other packets sent out (so the list should be filled with MAX_SEQN values if there are no more packets to be sent over). 

Outside of the libraries the TAs provided, we also used "algorithm" library to utilize the find function to see if the expected ack number, from server to client, is within the list of sequence numbers we are expecting (except for when the value is 25601, which means that there's no other values to be expected).
